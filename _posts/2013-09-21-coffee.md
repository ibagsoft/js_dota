---
layout: post
title: CoffeeScript
tags: 函数定义 作用域 类
description: CoffeeScript
---



> 可通过添加微信公共帐号`icodekata`，或者微博帐号`姜志辉iS`与我讨论


## 函数

### 函数定义

	hi = -> 'Hello,coffee'
	
CoffeeScript的函数声明采用的是定义式函数

	var hi;
	hi = function() {
    	return 'Hello,coffee';
    };
  	
因此，在使用前必须先定义他们。

### is

	cube = (num) ->
		console.log "you input #{arguments[0]}"
		console.log num % 2 is 1
		Math.pow num,3

	console.log cube(5)
	
CoffeeScript中的is和==都会编译为Javascript中的===，无法使用如Javascript中==那样宽松的、强制类型转化的等于检查。

### 向Ruby学习

从此处我们可以看到向Ruby学习的部分：

#### #{arguments[0]}

字符串插值语法与Ruby的类似："#{expression}"

#### return

隐式返回每个函数最后一个表达式的值

#### unless

	odd = (num) ->
		unless typeof num is 'number'
			throw '#{num} is not a number'
		unless num is Math.round num
			throw '#{num} is not an integer'
		unless num > 0
			throw '#{num} is not positive'
		num % 2 is 1

	console.log odd 7
	
#### Ruby code

	def odd(num)
		throw "#{num} is not a Fixnum" unless num.class == Fixnum
		throw "#{num} is not positive" unless num > 0
		num % 2 == 1
	end

	puts odd(5)
	
## 作用域

### 变量与作用域

	odd = (num) ->
		isNumber = (num) ->
			typeof num is 'number'
		isInteger = (num) ->
			num is Math.round num
		throw "#{num} is not a Number" unless isNumber num
		throw "#{num} is not an Integer" unless isInteger num
		num % 2 is 1

	console.log odd 5
	console.log odd '3'
	
使用-c将coffee转化为js文件：

	// Generated by CoffeeScript 1.6.3
  	(function() {
    	var odd;

    odd = function(num) {
      var isInteger, isNumber;
      isNumber = function(num) {
        return typeof num === 'number';
      };
      isInteger = function(num) {
        return num === Math.round(num);
      };
      if (!isNumber(num)) {
        throw "" + num + " is not a Number";
      }
      if (!isInteger(num)) {
        throw "" + num + " is not an Integer";
      }
      return num % 2 === 1;
    };

    console.log(odd(5));

    console.log(odd('3'));

  	}).call(this);
  	
CoffeeScript处理作用域的方式与JavaScript保持一致。但去掉了臭名昭著的var。

### @

	setName = (name) -> @name = name
	
使用@name代替this.name。其余与js相同：

assert = require 'assert'

	setName = (name) -> @name = name

	cat = 
		setName:setName

	cat.setName 'jobs'
	assert.equal 'jobs',cat.name

	setName 'gatsby'
	assert.equal 'gatsby',name

	pig = {}
	setName.apply pig,['gates']
	assert.equal 'gates',pig.name

	jobs = new setName 'jobs'
	assert.equal 'jobs',jobs.name
	
在此分别采用了方法、函数、apply、new四种调用方式，与js的4种调用匹配，结果是一样的。
那么CoffeeScript有哪些独到之处呢？

### =>

CoffeeScript使函数绑定到当前作用域非常简单，只需要一个`=>`即可：

	setName = (name) => @name = name

无论该函数在哪里调用，函数内部的this与函数定义时所在位置的this是一样的。

